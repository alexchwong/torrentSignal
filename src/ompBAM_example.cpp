#include "Rcpp.h"
using namespace Rcpp;

// Required to print cout output generated by ompBAM
#define cout Rcpp::Rcout

#include <string.h>
#include <cstdint>    	// int32_t, uint32_t
#include <sys/types.h>  // size_t, other type definitions
#include <vector>     	// std::vector
#include <map>        	// std::map
#include <math.h>


// [[Rcpp::depends(ompBAM)]]
#include <ompBAM.hpp>

#include "htslib/hts.h"
#include "htslib/hfile.h"
#include "htslib/sam.h"
#include "htslib/bgzf.h"
#include "htslib/thread_pool.h"

unsigned int use_threads(int n_threads = 1) {
  #ifdef _OPENMP
  if(n_threads <= 1) return(1);
  if(n_threads > omp_get_max_threads()) {
    return((unsigned int)omp_get_max_threads());
  }
  return((unsigned int)n_threads);
  #else
  return(1);
  #endif
}

std::string reverseComplement(std::string dna) {
    // 1. Define the complement map (handling both cases for robustness)
    std::unordered_map<char, char> complementMap = {
      {'A', 'T'}, {'T', 'A'}, {'C', 'G'}, {'G', 'C'},
      {'a', 't'}, {'t', 'a'}, {'c', 'g'}, {'g', 'c'}
  };

  // 2. Reverse the DNA string
  std::reverse(dna.begin(), dna.end());

  // 3. Apply the complement mapping using std::transform
  std::transform(dna.begin(), dna.end(), dna.begin(),
    [&](char base) {
      // Find the complement, default to original if not found (e.g., for 'N')
      return complementMap.count(base) ? complementMap[base] : base;
    });

  return dna;
}

// [[Rcpp::export]]
List c_getSignal(
    std::string bam_file,
    std::string binned_region, // e.g. "chr20:31022442-31022449"
    std::string seqname, int start, int end, // cos I'm too lazy to parse above
    StringVector rg_name, StringVector rg_KS, StringVector rg_FO
){
  List NULL_SIGNAL = List::create(
    _["values_pos"] = 0,
    _["values_neg"] = 0
  );

  std::string s_bam = bam_file;
  samFile *fp_bam = sam_open(s_bam.c_str(), "rb");
  if (fp_bam == NULL) {
    cout << s_bam << " opening failed, exiting\n";
    return(NULL_SIGNAL);
  }
  hts_idx_t *idx = sam_index_load(fp_bam, s_bam.c_str()); // Or just NULL if index is in default location
  if (idx == NULL) {
    cout << s_bam << " index not found or failed opening, exiting\n";
    return(NULL_SIGNAL);
  }

  sam_hdr_t *header = sam_hdr_read(fp_bam);

  hts_itr_t *iter = sam_itr_querys(idx, header, binned_region.c_str());
  if (iter == NULL) {
    cout << binned_region << " index query failed\n";
    return(NULL_SIGNAL);
  }

  std::vector<int16_t> values_pos;
  std::vector<int16_t> values_neg; // on negative strand
  int NEG_STRAND_FLAG = 16;
  bool isNegStrand = false;
  int target_pos = 0;

  // "chr20:31022442-31022449"

  std::string my_ks;
  std::string my_fo;
  std::string my_seq;
  std::string my_5p_seq;
  bool ks_found = false;
  
  int debug_read_count = 0;
  int debug_threshold = -1;

  bam1_t *b = bam_init1(); // Allocate memory for a BAM alignment record
  while (sam_itr_next(fp_bam, iter, b) >= 0) {
    // Process the BAM alignment record 'b'
    // Access fields like b->core.pos, b->core.l_qseq, bam_get_qname(b), etc.

    // (1) Determine if read aligns to positive or negative strand
    isNegStrand = false;
    target_pos = start;
    if (b->core.flag & NEG_STRAND_FLAG) {
      isNegStrand = true;
      target_pos = end;
    }

    // if(debug_read_count < debug_threshold) 
      // cout << "Processing " << bam_get_qname(b);

    // (2) Determine the 5' trimmed sequence
    //     - this is done by:
    //       (a) - determine the read group of the read
    //       (b) - find the corresponding rg_seq_prefix
    my_ks.clear();
    my_fo.clear();
    ks_found = false;
    uint8_t *rg_tag = bam_aux_get(b, "RG");
    if (rg_tag) {
      char *rg_value = bam_aux2Z(rg_tag);
      for(int z = 0; z < rg_name.size(); z++) {
        if(std::string(rg_value) == std::string(rg_name(z))) {
          my_ks = std::string(rg_KS(z));
          my_fo = std::string(rg_FO(z));
          ks_found = true;
          break;
        }
      }

    // (3) Determine the aligned sequence upstream to the bin of interest
    //     - this is done by:
    //       (a) - get the read cigar and the start position
    //       (b) - walk the cigar / SEQ until we reach the bin start position

      if(ks_found) {
        if(debug_read_count < debug_threshold) {
          if(isNegStrand) {
            cout << "(-) ";
          } else {
            cout << "(+) ";            
          } 
        }

        uint32_t *cigar = bam_get_cigar(b); // Get a pointer to the CIGAR array
        int n_cigar = b->core.n_cigar; // Number of CIGAR operations

        int seq_pos = 0; // how many nucleotides of aligned sequence to add
        int ref_pos = int(b->core.pos);

        bool cigar_exit = false;
        for (int i = 0; i < n_cigar; ++i) {
          if(cigar_exit) break;
          
          uint32_t op = cigar[i];
          int len = bam_cigar_oplen(op); // Length of the operation
          char op_char = bam_cigar_opchr(op); // Character representation of the operation (e.g., 'M', 'I', 'D')

          if(debug_read_count < debug_threshold) cout << 
            op_char << len << ",";

          switch (op_char) {
            case 'M': case '=': case 'X':
            // consume ref and query
            // may need to break prior to end of this cigar op
              if(ref_pos + len >= target_pos) {
                if(debug_read_count < debug_threshold) cout << 
                  (target_pos - ref_pos) << ",";
                
                seq_pos += (target_pos - ref_pos);
                ref_pos = target_pos;
                cigar_exit = true;
                break;
              } else {
                seq_pos += len;
                ref_pos += len;
                break;
              }

            case 'D': case 'N':
            // consume ref
              if(ref_pos + len >= target_pos) {
                cigar_exit = true;
                break;
              } else {
                ref_pos += len;
                break;
              }
            case 'I': case 'S':
            // consume query
              seq_pos += len;
              break;

            case 'H': case 'P':
            // consume neither; skip
              continue;
          }
        }
        if(debug_read_count < debug_threshold) cout << ref_pos << "," << seq_pos << ",";

        // get read sequence
        my_seq.clear();
        uint8_t *seq_packed = bam_get_seq(b);
        int read_length = b->core.l_qseq;

        for (int i = 0; i < read_length; ++i) {
          char base = seq_nt16_str[bam_seqi(seq_packed, i)];
          my_seq += base;
        }
        if(isNegStrand) {
          my_seq = reverseComplement(my_seq);
          seq_pos = read_length - seq_pos;
        }

    // (4) Concatenate the 5'-trimmed sequence and the sequence prior to the bin
        my_ks += my_seq.substr(0, seq_pos + 1);
        if(debug_read_count < debug_threshold) cout << my_ks;
    // (5) Using the flow order, determine the index of the signal of interest

        // reduce 5'-sequence to unique nucleotides
        std::string unique_ks = my_ks;
        unique_ks.erase(
          std::unique(unique_ks.begin(), unique_ks.end()),
          unique_ks.end()
        );


    // (6) Add the signal to either values_pos or values_neg
        uint8_t * aux_data = bam_aux_get(b, "ZM");
        if (aux_data && *aux_data == 'B') {
          char subtype = *(aux_data + 1);
          if (subtype == 's') { // Check if it's an array of integers
            uint32_t array_len = bam_auxB_len(aux_data);

            int idx = 0; // index of signal of interest
            int seq_idx = 0;
            while(seq_idx < (int)unique_ks.size() && (uint32_t)idx < array_len) {
              // my_fo
              if(unique_ks.at(seq_idx) == my_fo.at(idx)) {
                // if(debug_read_count < debug_threshold) cout << 
                  // my_fo.at(idx) << bam_auxB2i(aux_data, (uint32_t)idx) << ",";
                seq_idx++;
              }
              idx++;
            }
            idx--;

            // retrieve using array_ptr[idx]
            if((uint32_t)idx < array_len) {
              if(isNegStrand) {
                values_neg.push_back(bam_auxB2i(aux_data, (uint32_t)idx));
              } else {
                values_pos.push_back(bam_auxB2i(aux_data, (uint32_t)idx));
              }
              if(debug_read_count < debug_threshold) cout << " signal "
                << bam_auxB2i(aux_data, (uint32_t)idx)
                << "\n";
            } else {
              if(debug_read_count < debug_threshold) cout << " signal not found\n ";
            }
          }
        }

      // end of if(ks_found)
      } else {
        if(debug_read_count < debug_threshold) cout << "\n";
      }

    // end of if(rg_tag)
    } else {
      if(debug_read_count < debug_threshold) cout << "\n";
    }
    debug_read_count++;
  }

  // Clean up
  bam_destroy1(b);
  hts_itr_destroy(iter);

  hts_idx_destroy(idx);
  sam_close(fp_bam);

  List SIGNALS = List::create(
    _["values_pos"] = values_pos,
    _["values_neg"] = values_neg
  );

  return(SIGNALS);
}

// [[Rcpp::export]]
int idxstats_pbam(std::string bam_file, int n_threads_to_use = 1){

  // Ensure number of threads requested < number of system threads available
  unsigned int n_threads_to_really_use = use_threads(n_threads_to_use);

  pbam_in inbam;
  inbam.openFile(bam_file, n_threads_to_really_use);

  std::vector<std::string> s_chr_names;
  std::vector<uint32_t> u32_chr_lens;
  int chrom_count = inbam.obtainChrs(s_chr_names, u32_chr_lens);

  // If obtainChrs returns zero or negative # chromosomes, BAM reading has failed
  if(chrom_count <= 0) return(-1);

  // Creates a data structure that stores per-chromosome read counts
  std::vector<uint32_t> total_reads(chrom_count);

  while(0 == inbam.fillReads()) {
    // OpenMP parallel FOR loop, each thread runs 1 loop simultaneously.
    #ifdef _OPENMP
    #pragma omp parallel for num_threads(n_threads_to_really_use) schedule(static,1)
    #endif
    for(unsigned int i = 0; i < n_threads_to_really_use; i++) {
      std::vector<uint32_t> read_counter(chrom_count);

      // Gets the first read from the thread read storage buffer
      pbam1_t read(inbam.supplyRead(i));
      // Keep looping while reads are valid
      while(read.validate()) {
        // Counts the read if it is mapped to a chromosome
        if(read.refID() >= 0 && read.refID() < chrom_count) {
          read_counter.at(read.refID())++;
        }

        // Gets the next read
        read = inbam.supplyRead(i);
      }
      // Adds the counted reads to the final count
      // #pragma omp critical ensures only 1 thread at a time runs the following
      // block of code.
      #ifdef _OPENMP
      #pragma omp critical
      #endif
      for(unsigned int j = 0; j < (unsigned int)chrom_count; j++) {
        total_reads.at(j) += read_counter.at(j);
      }
    }
    // At this stage, all threads would have read all their thread-specific reads
    // At the next call to pbam_in::fillReads(), if any reads were not read, it
    // will throw an error and fillReads() will return -1.
    // If we have finished reading the BAM file, fillReads() will return 1.
  }

  inbam.closeFile();

  // Prints out the count summary to console output
  Rcout << bam_file << " summary:\n" << "Name\tLength\tNumber of reads\n";
  for(unsigned int j = 0; j < (unsigned int)chrom_count; j++) {
    Rcout << s_chr_names.at(j) << '\t' << u32_chr_lens.at(j) << '\t'
      << total_reads.at(j) << '\n';
  }
  return(0);
}
